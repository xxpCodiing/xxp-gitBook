{"./":{"url":"./","title":"简介","keywords":"","body":"关于此篇文档 用于记录自己在工作和开发中遇到的一些问题，稍作整理 Copyright © xxp 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-12-22 11:33:42 "},"COMPATIBLE_BOOK/ie.html":{"url":"COMPATIBLE_BOOK/ie.html","title":"兼容性整理","keywords":"","body":"兼容问题 链接：兼容性查看站点 对 IE 浏览器的兼容问题，可以大致分为 A 级兼容（Chrome、Firefox、IE9+）：要保证在最新浏览器上完美实现设计稿； B 级兼容（IE8）：能用且差别不大； C 级兼容（IE7 以下）：能用。 处理兼容问题的思路 首先以最大程度完善设计稿为基础，再考虑兼容性，不能盲目为了兼容问题而弃用方便简洁的新方法（如 HTML5、CSS3）；当然也不能用过新的技术方法使得兼容性过于低、实用性差。 常用的兼容解决方式 条件注释 You are using Internet Explorer 6. alert(1); 注：IE10 不再支持条件注释 js判断浏览器类型 navigator.userAgent对象 var browser = { versions: function () { var u = navigator.userAgent, app = navigator.appVersion; return { //移动终端浏览器版本信息 trident: u.indexOf('Trident') > -1, //IE内核 presto: u.indexOf('Presto') > -1, //opera内核 webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核 gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核 mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端 ios: !!u.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端 android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或uc浏览器 iPhone: u.indexOf('iPhone') > -1, //是否为iPhone或者QQHD浏览器 iPad: u.indexOf('iPad') > -1, //是否iPad webApp: u.indexOf('Safari') == -1 //是否web应该程序，没有头部与底部 }; }(), language: (navigator.browserLanguage || navigator.language).toLowerCase() } 一 HTML5标签兼容性 解决方法 二 CSS3兼容性 css3 属性兼容列表 css3 选择器兼容列表 默认margin padding 不同 h1-h6,ol,ul,p,form 等...标签中有默认的margin padding 值 *{margin:0;padding:0;} 仅在ie中生效的css @media screen and(-ms-high-contrast:active),(-ms-high-contrast:none){ .search-card-list-body{ margin-bottom: 20px; } } CSS Hack .box { color: red; _color: blue; /* IE6 下它生效 */ *color: pink; /* IE67 下它生效 */ color: yellow\\9; /* IE/Edge 6-8 下它生效 */ } 链接：更多cssHack方式 参考 CSS hack合集_w3cschool 各主流浏览器私有属性兼容 Webkit 类型（如 Safari、Chrome）的私有属性是以-webkit-前缀开始。 Gecko 类型（如 Firefox）的私有属性是以-moz-前缀开始。 presto 类型（Opera）的私有属性是以-o-前缀开始 trident 类型 （IE）的私有属性是以-ms-前缀开始 Konqueror 类型的浏览器的私有属性是以-khtml-前缀开始 解决方式：postcss和autoprefixer // 安装 npm install postcss npm install autoprefixer // 使用 module:{ rules:[ { test:/\\.vue$/, loader: 'vue-loader', options:{ vueLoaderConfig, postcss:[require('autoprefixer')({ browsers: ['last 10 Chrome versions', 'last 5 Firefox versions', 'Safari >= 6', 'ie> 8'] })] } }, // 配置 \"browserList\":[ \"> 1%\", \"Last 2 versions\", \"not ie = 8\", \"Firefox >= 20\", \"Android > 4.4\" ] 三 JS 兼容性 1. ES6 桌面浏览前对ES6的支持情况 Chrome：51 版起便可以支持 97% 的 ES6 新特性。 Firefox：53 版起便可以支持 97% 的 ES6 新特性。 Safari：10 版起便可以支持 99% 的 ES6 新特性。 IE：Edge 15可以支持 96% 的 ES6 新特性。Edge 14 可以支持 93% 的 ES6 新特性。（IE7~11 基本不支持 ES6） 保证es6的兼容性的方式 比较通用的工具方案有 babel，traceur，es6-shim 等 解决用例 引入browser.min.js ; script标签的type的值设为text/babel。 Document const list = ['one','two','three']; list.forEach( (item,index) => { alert(item + (index+1)); }); Polyfill（代码填充） 的技术。 使用babel编译 // 安装babel npm install --save-dev @babel/core @babel/cli @babel/preset-env @babel-loader // .babelrc 文件 presets: \"presets\": [ \"es2015\",\"stage-0\"], /** webpack 配置 **/ // entry 节点 entry: { app: ['babel-polyfill', './src/main.js'] } // 配置loader { test: /\\.js$/, exclude: /node_modules/, loader: 'babel-loader' } traceur 使用 import './Greeter.js'; // 第一个是加载 Traceur 的库文件 ; 第二个和第三个是将这个库文件用于浏览器环境 // type = module 这是Traceur编译器识别ES6代码的标志 自动将里面的代码编译成es5 /*更精确的Traceur配置*/ // Create the System object window.System = new traceur.runtime.BrowserTraceurLoader(); // Set some experimental options var metadata = { traceurOptions: { experimental: true, properTailCalls: true, symbols: true, arrayComprehension: true, asyncFunctions: true, asyncGenerators: exponentiation, forOn: true, generatorComprehension: true } }; // Load your module System.import('./myModule.js', {metadata: metadata}).catch(function(ex) { console.error('Import failed', ex.stack || ex); }); es6-shim npm install es6-shim -------------------- require('es6-shim'); 链接:es6-shim 文档 2. PROMISE AJAX FETCH AXIOS promise 兼容 ajxa 兼容性 IE下 responseType不支持json 会返回undefined 添加meta 强制edge json2.js json3.js 序列化返回 fetch 兼容 isomorphic-fetch 解决 import 'isomorphic-fetch' 使用三方库解决 原生支持率并不高，幸运的是，引入下面这些 polyfill 后可以完美支持 IE8+ ： 由于 IE8 是 ES3，需要引入 ES5 的 polyfill: es5-shim, es5-sham 引入 Promise 的 polyfill: es6-promise 引入 fetch 探测库：fetch-detector 引入 fetch 的 polyfill: fetch-ie8 可选：如果你还使用了 jsonp，引入 fetch-jsonp 可选：开启 Babel 的 runtime 模式，现在就使用 async/await Fetch polyfill 的基本原理是探测是否存在 window.fetch 方法，如果没有则用 XHR 实现。这也是 github/fetch 的做法，但是有些浏览器（Chrome 45）原生支持 Fetch，但响应中有中文时会乱码，老外又不太关心这种问题，所以我自己才封装了 fetch-detector 和 fetch-ie8 只在浏览器稳定支持 Fetch 情况下才使用原生 Fetch。这些库现在 每天有几千万个请求都在使用，绝对靠谱 ！ 终于，引用了这一堆 polyfill 后，可以愉快地使用 Fetch 了。但要小心，下面有坑： 链接：fetch兼容相关问题 四 BOM DOM兼容性 五 HACK兼容写法 六 项目中遇到的兼容问题 Copyright © xxp 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-12-25 18:16:21 "},"CSS-BOOK/":{"url":"CSS-BOOK/","title":"css前端学习整理","keywords":"","body":"简介 css的一些整理 Copyright © xxp 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-12-22 11:33:42 "},"CSS-BOOK/cssLearn-ali.html":{"url":"CSS-BOOK/cssLearn-ali.html","title":"渡一 前端学习","keywords":"","body":"渡一前端学习 一般 行级元素只能嵌套行级元素 块级元素可以嵌套任何元素(p标签里面不能套块级元素) a标签不能嵌套a标签 通用字体 乔布斯font-family:arial 主流浏览器及内核ie -trident chorome-webkit safari-webkit firefox -Gecko opera-presto css优先级和权重 name lev !important Infinity(无穷) 行间样式 10000 id 100 class、伪类、属性 10 标签、伪元素 1 通配符 0 行级元素、内联元素 inline特点:内容决定元素所占位置,不可通过css改变宽高 凡是带有inline的元素，都有文字特性 display:inline-block是基于下基准线对齐，调整不要vertical-align处理 初始化样式（针对不同标签样式）text-decoration:none; font-style:normal; list-style:none; padding:0; margin:0； body默认margin值：8px 盒模型上下左右居中外层盒子的宽高=内层盒子的宽高,再给外层盒子设置padding值 盒模型的计算width height border padding 定位 absolute 绝对定位脱离原来位置进行定位、脱离文档流 相对最近有定位的父级进行定位，如果没有，那么相对文档进行定位 配合 top left;right bottom relative 相对定位保留原来位置进行定位 配合 top left； right bottom fixed 固定定位固定不动 配合 top left ;right bottom 注意 position:absolute float:left/right 在内部会把元素转换成inline-block margin 塌陷 垂直方向margin,父子元素结合到一起了，会去最大那个值 弥补方式 bfc - block format content(块级格式化上下文) position:absolute display:inline-block float:left/right overflow:hidden 兄弟机构的margin-bottom和margin-top合并在一起了，可以使外层变成bfc模式，也可通过数学方式解决 浮动 float:left/right浮动元素产生了浮动流 所有产生了浮动流的元素： *块级元素看不到他们 *产生了bfc的元素和文本类属性(inline)的元素以及文本都能看到浮动元素 清除浮动{ clear:both; // 必须是块级元素 } // 举个例子 .clear:after, .clear:after { content: '\\20'; display: block; height: 0; clear: both; } .clear, .clear { *zoom: 1; } 伪元素 伪元素天生是行级元素，必须加content才能生效 example::after{ content:'', display:'block' } Copyright © xxp 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-12-25 11:35:35 "},"JS-BOOK/":{"url":"JS-BOOK/","title":"js整理","keywords":"","body":"js相关 收录一些常用到的，避免自己搞忘了的javascript相关 Copyright © xxp 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-12-22 11:33:42 "},"JS-BOOK/js-design.html":{"url":"JS-BOOK/js-design.html","title":"javaScript设计模式","keywords":"","body":"javascript 设计模式 单例模式 保证只有一个实例，并提供一个访问它的全局访问点 实现1:对象字面量var singleton = { attr : 1, method : function(){ return this.attr; } } var t1 = singleton ; var t2 = singleton ; 那么很显然的， t1 === t2 。 不足之处在于没有什么封装性，所有的属性方法都是暴露的 实现2：构造函数内部判断function Construct(){ // 确保只有单例 if( Construct.unique !== undefined ){ return Construct.unique; } // 其他代码 this.name = \"NYF\"; this.age=\"24\"; Construct.unique = this; } var t1 = new Construct() ; var t2 = new Construct() ; 那么也有的， t1 === t2 。 无非就是提出一个属性来做判断，但是该方式也没有安全性，一旦我在外部修改了Construct的unique属性，那么单例模式也就被破坏了。 实现3：闭包方式var single = (function(){ var unique; function Construct(){ // ... 生成单例的构造函数的代码 } unique = new Constuct(); return unique; })(); var t1 = single; var t2 = single; 不过相对而言更安全一点，当然也不是绝对安全。 如果希望会用调用 single() 方式来使用，那么也只需要将内部的 return 改为 return function(){ return unique; } 策略模式 代理模式 迭代器模式 观察者模式 观察者模式又称“发布-订阅（Publish/Subscribe）模式”/**发布者**/ function Publisher(){ this.observers = []; this.state = \"\"; } // 新增观察者 Publisher.prototype.addOb=function(observer){ var flag = false; for (var i = this.observers.length - 1; i >= 0; i--) { if(this.observers[i]===observer){ flag=true; } }; if(!flag){ this.observers.push(observer); } return this; } // 删除观察者 Publisher.prototype.removeOb=function(observer){ var observers = this.observers; for (var i = 0; i 大家看到，我们在最后对发布者手动设置了它的内容（state）并且要求他发出通知（notice）。在实际项目中，发布者的内容可能是从后台获取的也可能是从前台某地方输入的。然而发布者每次更新内容后又要手动调用通知是不是有点多余呢？既然更新了内容那就肯定要通知别人了啊。那我们就把内容的更新与发出通知进行绑定好了.看下面的代码//发布者 function Publisher(){ this.observers = []; var state = \"\"; //让该内容不能直接访问 //新增两个对于state的操作 获取/更新 this.getState=function(){ return state; } this.setState=function(value){ state = value; this.notice(); } } Publisher.prototype.addOb=function(observer){ var flag = false; for (var i = this.observers.length - 1; i >= 0; i--) { if(this.observers[i]===observer){ flag=true; } }; if(!flag){ this.observers.push(observer); } return this; } Publisher.prototype.removeOb=function(observer){ var observers = this.observers; for (var i = 0; i 实际应用// 全局发布-订阅对象 let Event = (function () { // 缓存列表，存放订阅者的回调函数 let clientList = {} let listen, trigger, remove // 增加订阅者 listen = (key, fn) => { if (!clientList[key]) { clientList[key] = [] } clientList[key].push(fn) }, // 发布消息 trigger = (...value) => { let key = Array.prototype.shift.call(value) let fns = clientList[key] // 如果没有绑定的对应的消息 if (!fns || fns.length === 0) { return false } for ( let i = 0, fn; fn = fns[i++]; ) { fn.apply(this, value) } }, // 取消订阅事件 remove = (key, fn) => { let fns = clientList[key] // 如果key对应的消息没有被人订阅，则直接返回 if (!fns) { return false } if (!fn) { // 如果没有传入具体的回调函数，表示需要取消key对应消息的所有订阅 fns && (fns.length = 0) } else { for (let l = fns.length - 1; l >= 0; l--) { let _fn = fns[l] if (_fn === fn) { fns.splice(l, 1) // 删除订阅者的回调函数 } } } } return { listen, trigger, remove } })() // 小明订阅消息 Event.listen('squareMeter88', fn1 = function (price, squareMeter) { console.log('小明先生：') console.log('price = ' + price) console.log('squareMeter = ' + squareMeter) }) // 小红订阅消息 Event.listen('squareMeter88', fn2 = function (price, squareMeter) { console.log('小红小姐：') console.log('price = ' + price) console.log('squareMeter = ' + squareMeter) }) // 售楼处发布消息 Event.trigger('squareMeter88', 10000, 88) Event.remove('squareMeter88', fn1) Event.trigger('squareMeter88', 15000, 88) 命令模式 组合模式 模板方式模式 享元模式 职责链模式 中介模式 装饰者模式 状态模式 适配器模式 好莱坞原则 依赖倒置原则 控制反转 依赖注入 Copyright © xxp 2019 all right reserved，powered by Gitbook该文件修订时间： 2020-12-22 11:33:42 "}}