{"./":{"url":"./","title":"简介","keywords":"","body":"关于此篇文档 用于记录自己在工作和开发中遇到的一些问题，稍作整理 Copyright © xxp 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 11:43:04 "},"CSS-BOOK/":{"url":"CSS-BOOK/","title":"css前端学习整理","keywords":"","body":"简介 css的一些整理 Copyright © xxp 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 13:46:22 "},"CSS-BOOK/cssLearn-ali.html":{"url":"CSS-BOOK/cssLearn-ali.html","title":"渡一前端学习","keywords":"","body":"渡一前端学习（阿里系） 一般 行级元素只能嵌套行级元素 块级元素可以嵌套任何元素(p标签里面不能套块级元素) a标签不能嵌套a标签 通用字体 乔布斯font-family:arial 主流浏览器及内核ie -trident chorome-webkit safari-webkit firefox -Gecko opera-presto css优先级和权重 name lev !important Infinity(无穷) 行间样式 10000 id 100 class、伪类、属性 10 标签、伪元素 1 通配符 0 行级元素、内联元素 inline特点:内容决定元素所占位置,不可通过css改变宽高 凡是带有inline的元素，都有文字特性 display:inline-block是基于下基准线对齐，调整不要vertical-align处理 初始化样式（针对不同标签样式）text-decoration:none; font-style:normal; list-style:none; padding:0; margin:0； body默认margin值：8px 盒模型上下左右居中外层盒子的宽高=内层盒子的宽高,再给外层盒子设置padding值 盒模型的计算width height border padding 定位 absolute 绝对定位脱离原来位置进行定位、脱离文档流 相对最近有定位的父级进行定位，如果没有，那么相对文档进行定位 配合 top left;right bottom relative 相对定位保留原来位置进行定位 配合 top left； right bottom fixed 固定定位固定不动 配合 top left ;right bottom 注意 position:absolute float:left/right 在内部会把元素转换成inline-block margin 塌陷 垂直方向margin,父子元素结合到一起了，会去最大那个值 弥补方式 bfc - block format content(块级格式化上下文) position:absolute display:inline-block float:left/right overflow:hidden 兄弟机构的margin-bottom和margin-top合并在一起了，可以使外层变成bfc模式，也可通过数学方式解决 浮动 float:left/right浮动元素产生了浮动流 所有产生了浮动流的元素： *块级元素看不到他们 *产生了bfc的元素和文本类属性(inline)的元素以及文本都能看到浮动元素 清除浮动{ clear:both; // 必须是块级元素 } // 举个例子 .clear:after, .clear:after { content: '\\20'; display: block; height: 0; clear: both; } .clear, .clear { *zoom: 1; } 伪元素 伪元素天生是行级元素，必须加content才能生效 example::after{ content:'', display:'block' } Copyright © xxp 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 14:26:31 "},"JS-BOOK/":{"url":"JS-BOOK/","title":"js整理","keywords":"","body":"js相关 收录一些常用到的，避免自己搞忘了的javascript相关 Copyright © xxp 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 14:50:39 "},"JS-BOOK/js-design.html":{"url":"JS-BOOK/js-design.html","title":"javaScript设计模式","keywords":"","body":"javascript 设计模式 单例模式 保证只有一个实例，并提供一个访问它的全局访问点 实现1:对象字面量var singleton = { attr : 1, method : function(){ return this.attr; } } var t1 = singleton ; var t2 = singleton ; 那么很显然的， t1 === t2 。 不足之处在于没有什么封装性，所有的属性方法都是暴露的 实现2：构造函数内部判断function Construct(){ // 确保只有单例 if( Construct.unique !== undefined ){ return Construct.unique; } // 其他代码 this.name = \"NYF\"; this.age=\"24\"; Construct.unique = this; } var t1 = new Construct() ; var t2 = new Construct() ; 那么也有的， t1 === t2 。 无非就是提出一个属性来做判断，但是该方式也没有安全性，一旦我在外部修改了Construct的unique属性，那么单例模式也就被破坏了。 实现3：闭包方式var single = (function(){ var unique; function Construct(){ // ... 生成单例的构造函数的代码 } unique = new Constuct(); return unique; })(); var t1 = single; var t2 = single; 不过相对而言更安全一点，当然也不是绝对安全。 如果希望会用调用 single() 方式来使用，那么也只需要将内部的 return 改为 return function(){ return unique; } 策略模式 代理模式 迭代器模式 观察者模式 观察者模式又称“发布-订阅（Publish/Subscribe）模式”/**发布者**/ function Publisher(){ this.observers = []; this.state = \"\"; } // 新增观察者 Publisher.prototype.addOb=function(observer){ var flag = false; for (var i = this.observers.length - 1; i >= 0; i--) { if(this.observers[i]===observer){ flag=true; } }; if(!flag){ this.observers.push(observer); } return this; } // 删除观察者 Publisher.prototype.removeOb=function(observer){ var observers = this.observers; for (var i = 0; i 大家看到，我们在最后对发布者手动设置了它的内容（state）并且要求他发出通知（notice）。在实际项目中，发布者的内容可能是从后台获取的也可能是从前台某地方输入的。然而发布者每次更新内容后又要手动调用通知是不是有点多余呢？既然更新了内容那就肯定要通知别人了啊。那我们就把内容的更新与发出通知进行绑定好了.看下面的代码//发布者 function Publisher(){ this.observers = []; var state = \"\"; //让该内容不能直接访问 //新增两个对于state的操作 获取/更新 this.getState=function(){ return state; } this.setState=function(value){ state = value; this.notice(); } } Publisher.prototype.addOb=function(observer){ var flag = false; for (var i = this.observers.length - 1; i >= 0; i--) { if(this.observers[i]===observer){ flag=true; } }; if(!flag){ this.observers.push(observer); } return this; } Publisher.prototype.removeOb=function(observer){ var observers = this.observers; for (var i = 0; i 实际应用// 全局发布-订阅对象 let Event = (function () { // 缓存列表，存放订阅者的回调函数 let clientList = {} let listen, trigger, remove // 增加订阅者 listen = (key, fn) => { if (!clientList[key]) { clientList[key] = [] } clientList[key].push(fn) }, // 发布消息 trigger = (...value) => { let key = Array.prototype.shift.call(value) let fns = clientList[key] // 如果没有绑定的对应的消息 if (!fns || fns.length === 0) { return false } for ( let i = 0, fn; fn = fns[i++]; ) { fn.apply(this, value) } }, // 取消订阅事件 remove = (key, fn) => { let fns = clientList[key] // 如果key对应的消息没有被人订阅，则直接返回 if (!fns) { return false } if (!fn) { // 如果没有传入具体的回调函数，表示需要取消key对应消息的所有订阅 fns && (fns.length = 0) } else { for (let l = fns.length - 1; l >= 0; l--) { let _fn = fns[l] if (_fn === fn) { fns.splice(l, 1) // 删除订阅者的回调函数 } } } } return { listen, trigger, remove } })() // 小明订阅消息 Event.listen('squareMeter88', fn1 = function (price, squareMeter) { console.log('小明先生：') console.log('price = ' + price) console.log('squareMeter = ' + squareMeter) }) // 小红订阅消息 Event.listen('squareMeter88', fn2 = function (price, squareMeter) { console.log('小红小姐：') console.log('price = ' + price) console.log('squareMeter = ' + squareMeter) }) // 售楼处发布消息 Event.trigger('squareMeter88', 10000, 88) Event.remove('squareMeter88', fn1) Event.trigger('squareMeter88', 15000, 88) 命令模式 组合模式 模板方式模式 享元模式 职责链模式 中介模式 装饰者模式 状态模式 适配器模式 好莱坞原则 依赖倒置原则 控制反转 依赖注入 Copyright © xxp 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-06-04 15:31:09 "}}